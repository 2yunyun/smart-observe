{"version":3,"file":"smart-observe.min.js","sources":["../src/util.js","../src/array.js","../src/observe.js","../src/expression.js","../node_modules/smart-next-tick/nextTick.js","../src/batcher.js","../src/watcher.js","../src/index.js","../src/dep.js","../src/constants.js"],"sourcesContent":["import {DEBUGGING} from './constants'\n\n/**\n * Define property with value.\n *\n * @param {Object} object\n * @param {String} property\n * @param {*} value\n * @param {Boolean} [enumerable]\n */\n\nexport function defineValue (object, property, value, enumerable) {\n  Object.defineProperty(object, property, {\n    value,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Define property with getter and setter.\n *\n * @param {Object} object\n * @param {String} property\n * @param {Function} getter\n * @param {Function} setter\n */\n\nexport function defineAccessor (object, property, getter, setter) {\n  Object.defineProperty(object, property, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Array type check.\n *\n * @return {Boolean}\n */\n\nexport const isArray = Array.isArray\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} object\n * @return {Boolean}\n */\n\nconst toString = Object.prototype.toString\nconst OBJECT_STRING = '[object Object]'\nexport function isPlainObject (object) {\n  return toString.call(object) === OBJECT_STRING\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} object\n * @return {Boolean}\n */\n\nexport function isObject (object) {\n  return object !== null && typeof object === 'object'\n}\n\n/**\n * Function type check\n *\n * @param {*} func\n * @param {Boolean}\n */\n\nexport function isFunction (func) {\n  return typeof func === 'function'\n}\n\n/**\n * Iterate object\n *\n * @param {Object} object\n * @param {Function} callback\n */\n\nexport function everyEntries (object, callback) {\n  const keys = Object.keys(object)\n  for (let i = 0, l = keys.length; i < l; i++) {\n    callback(keys[i], object[keys[i]])\n  }\n}\n\n/**\n * noop is function which is nothing to do.\n */\n\nexport function noop () {}\n\n/**\n * @param {String} string\n */\n\nexport const warn = typeof DEBUGGING !== undefined && DEBUGGING\n  && typeof console !== 'undefined' && console\n  && isFunction(console.warn)\n    ? console.warn\n    : noop\n\nexport let _Set\nif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n  // use native Set when available.\n  _Set = Set\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    this.set = Object.create(null)\n  }\n  _Set.prototype.has = function (key) {\n    return this.set[key] !== undefined\n  }\n  _Set.prototype.add = function (key) {\n    this.set[key] = 1\n  }\n  _Set.prototype.clear = function () {\n    this.set = Object.create(null)\n  }\n}\n","import {defineValue} from './util'\nimport {OBSERVE_NAME} from './constants'\n\nconst arrayPrototype = Array.prototype\nconst arrayMethods = Object.create(arrayPrototype)\nconst arrayMutativeMethods = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\n\n/**\n * Augment an target Array with arrayMethods\n *\n * @param {Array} array\n */\n\nexport default function amend (array) {\n  Object.setPrototypeOf(array, arrayMethods)\n}\n\n/**\n * Intercept mutating methods and emit events\n */\n\nfor (\n  let i = 0, l = arrayMutativeMethods.length, method;\n  i < l;\n  method = arrayMutativeMethods[++i]\n) {\n  // cache original method\n  const original = arrayPrototype[method]\n  defineValue(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const observer = this[OBSERVE_NAME]\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) observer.observeArray(inserted)\n    observer.dep.notify() // notify change\n    return result\n  })\n}\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} value\n * @return {*} - replaced element\n */\n\nfunction $set (index, value) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1\n  }\n  return this.splice(index, 1, value)[0]\n}\ndefineValue(arrayPrototype, '$set', $set)\n\n/**\n * Convenience method to remove the element at given index\n * or target element reference.\n *\n * @param {*} item\n * @return {*} - removed element\n */\n\nfunction $remove (item) {\n  if (!this.length) return\n  const index = this.indexOf(item)\n  if (index > -1) {\n    return this.splice(index, 1)\n  }\n}\ndefineValue(arrayPrototype, '$remove', $remove)\n","import Dep from './dep'\nimport amendArray from './array'\nimport {\n  defineValue,\n  defineAccessor,\n  isArray,\n  isPlainObject,\n  everyEntries,\n} from './util'\nimport {OBSERVE_NAME} from './constants'\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @class\n * @param {Array|Object} value\n */\n\nclass Observer {\n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()\n    defineValue(value, OBSERVE_NAME, this)\n    if (isArray(value)) {\n      amendArray(value)\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   *\n   * @param {Object} object\n   */\n\n  walk (object) {\n    everyEntries(object, (key, value) => this.convert(key, value))\n  }\n\n  /**\n   * Observe a list of Array items.\n   *\n   * @param {Array} items\n   */\n\n  observeArray (items) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n\n  /**\n   * Convert a property into getter/setter so we can emit\n   * the events when the property is accessed/changed.\n   *\n   * @param {String} key\n   * @param {*} value\n   */\n\n  convert (key, value) {\n    defineReactive(this.value, key, value)\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n */\n\nexport function observe (value) {\n  if (!value || typeof value !== 'object') return\n  let observer\n  if (\n    Object.prototype.hasOwnProperty.call(value, OBSERVE_NAME)\n    && value[OBSERVE_NAME] instanceof Observer\n  ) {\n    observer = value[OBSERVE_NAME]\n  } else if (\n    (isArray(value) || isPlainObject(value))\n    && Object.isExtensible(value)\n  ) {\n    observer = new Observer(value)\n  }\n  return observer\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} object\n * @param {String} key\n * @param {*} value\n */\n\nexport function defineReactive (object, key, value) {\n  const dep = new Dep()\n\n  const desc = Object.getOwnPropertyDescriptor(object, key)\n  if (desc && desc.configurable === false) return\n\n  // cater for pre-defined getter/setters\n  const getter = desc && desc.get\n  const setter = desc && desc.set\n\n  let childOb = observe(value)\n\n  function reactiveGetter () {\n    const currentValue = getter ? getter.call(object) : value\n    if (Dep.target) {\n      dep.depend()\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      if (isArray(currentValue)) {\n        for (let i = 0, l = currentValue.length, e; i < l; i++) {\n          e = currentValue[i]\n          e && e[OBSERVE_NAME] && e[OBSERVE_NAME].dep.depend()\n        }\n      }\n    }\n    return currentValue\n  }\n  function reactiveSetter (newValue) {\n    const oldValue = getter ? getter.call(object) : value\n    if (newValue === oldValue) return\n    if (setter) {\n      setter.call(object, newValue)\n    } else {\n      value = newValue\n    }\n    childOb = observe(newValue)\n    dep.notify()\n  }\n  defineAccessor(object, key, reactiveGetter, reactiveSetter)\n}\n","import {warn} from './util'\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFunction (body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', `return ${body};`)\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    warn('Invalid expression. Generated function body: ' + body)\n  }\n}\n\n/**\n * Parse an expression to getter.\n *\n * @param {String} expression\n * @return {Function|undefined}\n */\n\nexport default function parse (expression) {\n  expression = String.prototype.trim.call(expression)\n  return makeGetterFunction('scope.' + expression)\n}\n","var callbacks = []\nvar pending = false\nfunction nextTickHandler () {\n    pending = false\n    var callbackCopies = callbacks.slice(0)\n    callbacks.length = 0\n    for (var i = 0; i < callbackCopies.length; i++) {\n        callbackCopies[i]()\n    }\n}\n\nvar callNextTick\nif (typeof process === 'object'\n    && process\n    && typeof process.nextTick === 'function'\n) {\n    callNextTick = process.nextTick\n} else if (typeof MutationObserver !== 'undefined') {\n    var counter = 0\n    var textNode = document.createTextNode(counter)\n    var observer = new MutationObserver(nextTickHandler)\n    observer.observe(textNode, {\n        characterData: true\n    })\n    callNextTick = function () {\n        counter = counter === 0 ? 1 : 0\n        textNode.data = String(counter)\n    }\n} else {\n    callNextTick = setTimeout\n}\n\n\nmodule.exports = function nextTick (callback, context) {\n    var func = callback\n    if (context) {\n        var args = []\n        var l = arguments.length\n        while (--l > 1) {\n            args.unshift(arguments[l])\n        }\n        func = function () {\n            callback.apply(context, args)\n        }\n    }\n    callbacks.push(func)\n    if (pending) {\n        return\n    }\n    pending = true\n    callNextTick(nextTickHandler)\n}\n","import nextTick from 'smart-next-tick'\n\nlet queue = []\nlet has = {}\nlet waiting = false\nlet queueIndex\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    const watcher = queue[queueIndex]\n    const id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport default function batch (watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n","import observe from './index'\nimport Dep from './dep'\nimport parseExpression from './expression'\nimport batch from './batcher'\nimport {\n  isArray,\n  isObject,\n  isFunction,\n  _Set as Set,\n} from './util'\nimport {WATCHERS_PROPERTY_NAME} from './constants'\n\nlet uid = 0\n\nclass Watcher {\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   *\n   * @param {Object} owner\n   * @param {String|Function} getter\n   * @param {Function} callback\n   * @param {Object} options\n   *                 - {Boolean} deep\n   *                 - {Boolean} sync\n   *                 - {Boolean} lazy\n   * @constructor\n   */\n\n  constructor (owner, getter, callback, options) {\n    owner[WATCHERS_PROPERTY_NAME].push(this)\n    this.owner = owner\n    this.getter = getter\n    this.callback = callback\n    this.options = options\n    // uid for batching\n    this.id = ++uid\n    this.active = true\n    // for lazy watchers\n    this.dirty = options.lazy\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.value = options.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n  get () {\n    this.beforeGet()\n    const scope = this.owner\n    const value = this.getter.call(scope, scope)\n    if (this.options.deep) {\n      traverse(value)\n    }\n    this.afterGet()\n    return value\n  }\n\n  /**\n   * Prepare for dependency collection.\n   */\n\n  beforeGet () {\n    Dep.target = this\n  }\n\n  /**\n   * Add a dependency to this directive.\n   *\n   * @param {Dep} dep\n   */\n\n  addDep (dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n\n  afterGet () {\n    Dep.target = null\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Will be called when a dependency changes.\n   */\n\n  update () {\n    if (this.options.lazy) {\n      this.dirty = true\n    } else if (this.options.sync) {\n      this.run()\n    } else {\n      batch(this)\n    }\n  }\n\n  /**\n   * Will be called by the batcher.\n   */\n\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value\n        // Deep watchers and watchers on Object/Arrays should fire even when\n        // the value is the same, because the value may have mutated;\n        || ((isObject(value) || this.options.deep))\n      ) {\n        const oldValue = this.value\n        this.value = value\n        this.callback.call(this.owner, value, oldValue)\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n  evaluate () {\n    // avoid overwriting another watcher that is being collected.\n    const current = Dep.target\n    this.value = this.get()\n    this.dirty = false\n    Dep.target = current\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subcriber list.\n   */\n\n  teardown () {\n    if (this.active) {\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n      this.owner = this.callback = this.value = null\n    }\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} value\n */\n\nfunction traverse (value) {\n  let i, keys\n  if (isArray(value)) {\n    i = value.length\n    while (i--) traverse(value[i])\n  } else if (isObject(value)) {\n    keys = Object.keys(value)\n    i = keys.length\n    while (i--) traverse(value[keys[i]])\n  }\n}\n\n/**\n * Create an watcher instance, returns the new watcher.\n *\n * @param {Object} owner\n * @param {String|Function} expressionOrFunction\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @return {Watcher}\n */\n\nexport function watch (owner, expressionOrFunction, callback, options) {\n  // parse expression for getter\n  const getter = isFunction(expressionOrFunction)\n               ? expressionOrFunction\n               : parseExpression(expressionOrFunction)\n  return new Watcher(owner, getter, callback, options)\n}\n\n/**\n * Make a computed getter, which can collect dependencies.\n *\n * @param {Object} owner\n * @param {Function} getter\n */\n\nexport function makeComputed (owner, getter) {\n  const watcher = new Watcher(owner, getter, null, {\n    deep: observe.deep,\n    lazy: true,\n    sync: observe.sync,\n  })\n  return function computedGetter () {\n    if (watcher.options.lazy && Dep.target && !Dep.target.options.lazy) {\n      watcher.options.lazy = false\n      watcher.callback = function () {\n        const deps = watcher.deps\n        for (let i = 0, l = deps.length; i < l; i++) {\n          deps[i].notify()\n        }\n      }\n    }\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n","import {\n  observe as doObserve,\n  defineReactive,\n} from './observe'\nimport {\n  watch as doWatch,\n  makeComputed,\n} from './watcher'\nimport {\n  defineValue,\n  defineAccessor,\n  noop,\n  isFunction,\n  everyEntries,\n} from './util'\nimport {\n  WATCHERS_PROPERTY_NAME,\n  DATA_PROPTERTY_NAME,\n} from './constants'\n\nObject.defineProperties(observe, {\n  'react': {value: react},\n  'compute': {value: compute},\n  'watch': {value: watch},\n  'default': {value: watch, writable: true}, // Only could be react, compute or watch\n  'deep': {value: false, writable: true},\n  'lazy': {value: false, writable: true},\n  'sync': {value: false, writable: true},\n})\n\n/**\n * observe\n *\n * @public\n * @param {Object} target\n * @param {*} [expression]\n * @param {*} [func]\n * @param {*} [options]\n * @return {Function} observe\n */\n\nexport default function observe (target, expression, func, options) {\n  if (!target.hasOwnProperty(WATCHERS_PROPERTY_NAME)) {\n    init(target)\n  }\n  return observe.default(target, expression, func, options)\n}\n\n/**\n * React options\n *\n * @param {Object} options\n * @param {Object} [target]\n * @return {Function} observe\n */\n\nfunction react (options, target) {\n  if (target) {\n    if (!target.hasOwnProperty(WATCHERS_PROPERTY_NAME)) {\n      init(target)\n    }\n  } else {\n    target = {}\n    init(target)\n  }\n  options.methods && carryMethods(target, options.methods)\n  options.data && reactProperties(target, options.data)\n  options.computed && computeProperties(target, options.computed)\n  options.watchers && watchProperties(target, options.watchers)\n  return target\n}\n\n/**\n * Compute property\n *\n * @param {Object} target\n * @param {String} name\n * @param {Function|Object} getterOrAccessor\n *        - Function getter\n *        - Object accessor\n *          - Function [get]  - getter\n *          - Function [set]  - setter\n *          - Boolean [cache]\n * @param {Boolean} [cache]\n */\n\nfunction compute (target, name, getterOrAccessor, cache) {\n  if (!target.hasOwnProperty(WATCHERS_PROPERTY_NAME)) {\n    init(target)\n  }\n  let getter, setter\n  if (isFunction(getterOrAccessor)) {\n    getter = cache !== false\n            ? makeComputed(target, getterOrAccessor)\n            : getterOrAccessor.bind(this)\n    setter = noop\n  } else {\n    getter = getterOrAccessor.get\n            ? getterOrAccessor.cache !== false || cache !== false\n              ? makeComputed(target, getterOrAccessor.get)\n              : getterOrAccessor.get.bind(this)\n            : noop\n    setter = getterOrAccessor.set ? getterOrAccessor.set.bind(this) : noop\n  }\n  defineAccessor(target, name, getter, setter)\n}\n\n/**\n * Watch property\n *\n * @param {Object} target\n * @param {String|Function} expressionOrFunction\n * @param {Function} callback\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @return {Watcher}\n */\n\nfunction watch (target, expressionOrFunction, callback, options = observe) {\n  if (!target.hasOwnProperty(WATCHERS_PROPERTY_NAME)) {\n    init(target)\n  }\n  return doWatch(target, expressionOrFunction, callback, options)\n}\n\n/**\n * @param {Object} target\n */\n\nfunction init (target) {\n  defineValue(target, WATCHERS_PROPERTY_NAME, [], false)\n  defineValue(target, DATA_PROPTERTY_NAME, Object.create(null), false)\n  doObserve(target[DATA_PROPTERTY_NAME])\n  reactSelfProperties(target)\n}\n\n/**\n * @param {Object} target\n * @param {Object} methods\n */\n\nfunction carryMethods (target, methods) {\n  everyEntries(methods, (name, method) => {\n    target[name] = method.bind(target)\n  })\n}\n\n/**\n * @param {Object} target\n * @param {String} key\n * @param {*} value\n */\n\nfunction reactProperty (target, key, value) {\n  target[DATA_PROPTERTY_NAME][key] = value\n  defineReactive(target[DATA_PROPTERTY_NAME], key, value)\n  proxy(target, key)\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction reactProperties (target, properties) {\n  everyEntries(properties, (key, value) => reactProperty(target, key, value))\n}\n\n/**\n * @param {Object} target\n */\n\nfunction reactSelfProperties (target) {\n  everyEntries(target, (key, value) => {\n    !isFunction(value) && reactProperty(target, key, value)\n  })\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction computeProperties (target, properties) {\n  everyEntries(properties, (key, value) => compute(target, key, value))\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction watchProperties (target, properties) {\n  everyEntries(properties, (expression, functionOrOption) => {\n    if (isFunction(functionOrOption)) {\n      watch(target, expression, functionOrOption)\n    } else {\n      watch(target, expression, functionOrOption.watcher, functionOrOption)\n    }\n  })\n}\n\n/**\n * @param {Object} target\n * @param {String} key\n */\n\nfunction proxy (target, key) {\n  function getter () {\n    return target[DATA_PROPTERTY_NAME][key]\n  }\n  function setter (value) {\n    target[DATA_PROPTERTY_NAME][key] = value\n  }\n  defineAccessor(target, key, getter, setter)\n}\n","let uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * watcher subscribing to it.\n */\n\nexport default class Dep {\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  static target = null\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /**\n   * Add a subscriber.\n   *\n   * @param {Watcher} sub\n   */\n\n  addSub (sub) {\n    this.subs.push(sub)\n  }\n\n  /**\n   * Remove a subscriber.\n   *\n   * @param {Watcher} sub\n   */\n\n  removeSub (sub) {\n    this.subs.$remove(sub)\n  }\n\n  /**\n   * Add self as a dependency to the target watcher.\n   */\n\n  depend () {\n    Dep.target.addDep(this)\n  }\n\n  /**\n   * Notify all subscribers of a new value.\n   */\n\n  notify () {\n    const subs = this.subs\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n","export const OBSERVE_NAME = '__s_o__'\nexport const WATCHERS_PROPERTY_NAME = '__watchers__'\nexport const DATA_PROPTERTY_NAME = '__data__'\n\nexport const DEBUGGING = typeof process !== 'undefined'\n  && process.env.NODE_ENV !== 'production'\n"],"names":["defineValue","object","property","value","enumerable","defineProperty","defineAccessor","getter","setter","isPlainObject","toString","call","OBJECT_STRING","isObject","isFunction","func","everyEntries","callback","keys","Object","i","l","length","noop","amend","array","setPrototypeOf","arrayMethods","$set","index","this","Number","splice","$remove","item","indexOf","observe","observer","prototype","hasOwnProperty","OBSERVE_NAME","Observer","isArray","isExtensible","defineReactive","key","reactiveGetter","currentValue","Dep","target","depend","childOb","dep","e","reactiveSetter","newValue","oldValue","notify","desc","getOwnPropertyDescriptor","configurable","get","set","makeGetterFunction","body","Function","parse","expression","String","trim","nextTickHandler","callbackCopies","callbacks","slice","resetBatcherState","flushBatcherQueue","queue","runBatcherQueue","queueIndex","watcher","id","run","batch","has","push","waiting","traverse","watch","owner","expressionOrFunction","options","parseExpression","Watcher","makeComputed","deep","sync","lazy","deps","dirty","evaluate","WATCHERS_PROPERTY_NAME","default","react","methods","carryMethods","data","reactProperties","computed","computeProperties","watchers","watchProperties","compute","name","getterOrAccessor","cache","bind","doWatch","init","DATA_PROPTERTY_NAME","create","method","reactProperty","properties","reactSelfProperties","functionOrOption","proxy","uid","subs","sub","addDep","update","DEBUGGING","process","env","NODE_ENV","Array","warn","undefined","console","_Set","Set","match","add","clear","arrayPrototype","arrayMutativeMethods","original","args","result","apply","inserted","observeArray","callNextTick","walk","_this","convert","items","pending","nextTick","MutationObserver","counter","textNode","document","createTextNode","setTimeout","context","arguments","unshift","active","newDeps","depIds","newDepIds","beforeGet","scope","afterGet","addSub","removeSub","tmp","current","defineProperties","writable"],"mappings":"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"}