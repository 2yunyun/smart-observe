{"version":3,"file":"ob.min.js","sources":["../../../../../../\u0000babelHelpers","../src/utils.js","../src/dep.js","../src/array.js","../src/observe.js","../src/expression.js","../src/batcher.js","../src/watcher.js","../src/ob.js"],"sourcesContent":["var babelHelpers = {};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nexport var jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nexport var asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nexport var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexport var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexport var defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nexport var defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nexport var defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexport var get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nexport var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nexport var interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nexport var interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nexport var newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nexport var objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nexport var objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nexport var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nexport var selfGlobal = typeof global === \"undefined\" ? self : global;\n\nexport var set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nexport var slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexport var slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nexport var taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nexport var taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nexport var temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nexport var temporalUndefined = {};\n\nexport var toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nexport var toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nbabelHelpers;\n\nexport { _typeof as typeof, _extends as extends, _instanceof as instanceof }","/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexport function def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Function} getter\n * @param {Function} setter\n */\n\nexport function defi (obj, key, getter, setter) {\n  Object.defineProperty(obj, key, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: true,\n  })\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport const isArray = Array.isArray\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexport function isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexport function indexOf (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport function isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * every\n *\n * @param {Object} obj\n * @param {Function} cb\n */\n\nexport function every (obj, cb) {\n  var keys = Object.keys(obj)\n  for (var i = 0, l = keys.length; i < l; i++) {\n    cb(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * each\n *\n * @param {Array} arr\n * @param {Function} cb\n */\n\nexport function each (arr, cb) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    cb(arr[i], i)\n  }\n}\n\n/**\n * isFunc\n *\n * @param {*} func\n * @param {Boolean}\n */\n\nexport function isFunc (func) {\n  return typeof func === 'function'\n}\n\n/**\n * noop is function which is nothing to do.\n */\n\nexport function noop () {}\n\n/**\n * isDebug\n */\n\nexport const isDebug =\n  typeof process !== 'undefined'\n  && process.env.NODE_ENV !== 'production'\n\n/**\n * warn\n */\n\nexport const warn =\n  isDebug\n  && console\n  && isFunc(console.warn)\n    ? console.warn\n    : noop\n","import { each } from './utils'\n\nlet uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nexport default function Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  var subs = this.subs\n  each(subs, function (sub) {\n    sub.update()\n  })\n}\n","import {\n  def,\n  each,\n  indexOf,\n} from './utils'\n\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\nconst arrayMutating = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\n\n/**\n * Augment an target Array with arrayMethods\n *\n * @param {Array} arr\n */\n\nexport default function amend (arr) {\n  Object.setPrototypeOf(arr, arrayMethods)\n}\n\n/**\n * Intercept mutating methods and emit events\n */\n\neach(arrayMutating, function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\nfunction $set (index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1\n  }\n  return this.splice(index, 1, val)[0]\n}\ndef(arrayProto, '$set', $set)\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\nfunction $remove (item) {\n  /* istanbul ignore if */\n  if (!this.length) return\n  var index = indexOf(this, item)\n  if (index > -1) {\n    return this.splice(index, 1)\n  }\n}\ndef(arrayProto, '$remove', $remove)\n","import Dep from './dep'\nimport amendArray from './array'\nimport {\n  def,\n  defi,\n  every,\n  each,\n  isArray,\n  isPlainObject,\n} from './utils'\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  def(value, '__ob__', this)\n  if (isArray(value)) {\n    amendArray(value)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  every(obj, (key, val) => {\n    this.convert(key, val)\n  })\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  each(items, function (val) {\n    observe(val)\n  })\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n */\n\nexport function observe (value) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    Object.prototype.hasOwnProperty.call(value, '__ob__')\n    && value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (isArray(value) || isPlainObject(value))\n    && Object.isExtensible(value)\n  ) {\n    ob = new Observer(value)\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nexport function defineReactive (obj, key, val) {\n  var dep = new Dep()\n\n  var desc = Object.getOwnPropertyDescriptor(obj, key)\n  if (desc && desc.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = desc && desc.get\n  var setter = desc && desc.set\n\n  var childOb = observe(val)\n\n  function reactiveGetter () {\n    var value = getter ? getter.call(obj) : val\n    if (Dep.target) {\n      dep.depend()\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      if (isArray(value)) {\n        each(value, function (e) {\n          e && e.__ob__ && e.__ob__.dep.depend()\n        })\n      }\n    }\n    return value\n  }\n  function reactiveSetter (newVal) {\n    var value = getter ? getter.call(obj) : val\n    if (newVal === value) {\n      return\n    }\n    if (setter) {\n      setter.call(obj, newVal)\n    } else {\n      val = newVal\n    }\n    childOb = observe(newVal)\n    dep.notify()\n  }\n  defi(obj, key, reactiveGetter, reactiveSetter)\n}\n","import { warn } from './utils'\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn (body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';')\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    warn(\n      'Invalid expression. '\n      + 'Generated function body: '\n      + body\n    )\n  }\n}\n\n/**\n * Parse an expression to getter.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nexport default function parse (exp) {\n  exp = exp.trim()\n  var getter = makeGetterFn('scope.' + exp)\n  return getter\n}\n","var queueIndex\nvar queue = []\nvar has = {}\nvar waiting = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    var watcher = queue[queueIndex]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nconst nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    /* global MutationObserver */\n    var observer = new MutationObserver(nextTickHandler)\n    /* global */\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true,\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    const inBrowser = typeof window !== 'undefined'\n      && Object.prototype.toString.call(window) !== '[object Object]'\n    const context = inBrowser\n      ? window\n      : typeof global !== 'undefined' ? global : {}\n    timerFunc = context.setImmediate || setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport default function batch (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n","import Dep from './dep'\nimport parseExpression from './expression'\nimport batch from './batcher'\nimport {\n  isArray,\n  isObject,\n  isFunc,\n} from './utils'\n\nlet uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nfunction Watcher (owner, getter, callback, options) {\n  owner._watchers.push(this)\n  this.owner = owner\n  this.getter = getter\n  this.callback = callback\n  this.options = options\n  // uid for batching\n  this.id = ++uid\n  this.active = true\n  // for lazy watchers\n  this.dirty = options.lazy\n  this.deps = []\n  this.newDeps = []\n  this.depIds = Object.create(null)\n  this.newDepIds = null\n  this.value = options.lazy\n    ? undefined\n    : this.get()\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.owner\n  var value = this.getter.call(scope, scope)\n  if (this.options.deep) {\n    traverse(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDepIds = Object.create(null)\n  this.newDeps.length = 0\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDepIds[id]) {\n    this.newDepIds[id] = true\n    this.newDeps.push(dep)\n    if (!this.depIds[id]) {\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var i = this.deps.length\n  while (i--) {\n    var dep = this.deps[i]\n    if (!this.newDepIds[dep.id]) {\n      dep.removeSub(this)\n    }\n  }\n  this.depIds = this.newDepIds\n  var tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\nWatcher.prototype.update = function () {\n  if (this.options.lazy) {\n    this.dirty = true\n  } else if (this.options.sync) {\n    this.run()\n  } else {\n    batch(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value\n      // Deep watchers and watchers on Object/Arrays should fire even when\n      // the value is the same, because the value may have mutated;\n      || ((isObject(value) || this.options.deep))\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      this.callback.call(this.owner, value, oldValue)\n    }\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length\n  while (i--) {\n    this.deps[i].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    var i = this.deps.length\n    while (i--) {\n      this.deps[i].removeSub(this)\n    }\n    this.active = false\n    this.owner = this.callback = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\n/**\n * Create an watcher instance, returns the new watcher.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nexport function watch (owner, expOrFn, callback, options) {\n  // parse expression for getter\n  var getter = isFunc(expOrFn)\n               ? expOrFn\n               : parseExpression(expOrFn)\n  var instance = new Watcher(owner, getter, callback, options)\n  return instance\n}\n\n/**\n * Make a computed getter, which can collect dependencies.\n *\n * @param {Object} owner\n * @param {Function} getter\n */\n\nexport function makeComputed (owner, getter) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true,\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n","import {\n  observe,\n  defineReactive,\n} from './observe'\nimport {\n  watch as watche,\n  makeComputed,\n} from './watcher'\nimport {\n  def,\n  defi,\n  every,\n  noop,\n  isFunc,\n} from './utils'\n\nlet current = null\n\n // {Function} One of carry, react, compute, watch. Default is watch.\nob.default = watch\n\n// {Boolean} Default is true\nreactive.auto = true\n\n// {Boolean} Default is false\nwatch.deep = watch.lazy = watch.sync = false\n\nObject.setPrototypeOf(ob, {\n  reactive,\n  carry, $carry,\n  react, $react,\n  compute, $compute,\n  watch, $watch,\n})\n\n/**\n * ob\n *\n * @param {Object} owner\n * @param {*} [expr]\n * @param {*} [func]\n * @param {*} [opt]\n * @return {Function} ob\n */\n\nexport default function ob (owner, expr, func, opt) {\n  current = owner\n  var isOber = owner.hasOwnProperty('_watchers')\n  if (!isOber) {\n    init(owner)\n    if (reactive.auto) {\n      reactive()\n    }\n  }\n  if (expr) {\n    ob.default(expr, func, opt)\n  }\n  return ob\n}\n\n/**\n * init\n *\n * @param {Object} owner\n * @return {Function} ob\n */\n\nfunction init (owner) {\n  def(owner, '_watchers', [], false)\n  def(owner, '_data', Object.create(null), false)\n  observe(owner._data)\n  return ob\n}\n\n/**\n * reactive\n *\n * @param {Object} config\n * @return {Function} ob\n */\n\nfunction reactive (config) {\n  if (config) {\n    config.methods && $carry(config.methods)\n    config.data && $react(config.data)\n    config.computed && $compute(config.computed)\n    config.watchers && $watch(config.watchers)\n  } else {\n    every(current, function (key, val) {\n      !isFunc(val) && react(key, val)\n    })\n  }\n  return ob\n}\n\n/**\n * carry\n *\n * @param {String} key\n * @param {Function} method\n */\n\nfunction carry (key, method) {\n  current[key] = method.bind(current)\n  return ob\n}\n\n/**\n * $carry\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $carry (items) {\n  every(items, function (key, val) {\n    carry(key, val)\n  })\n  return ob\n}\n\n/**\n * react\n *\n * @param {String} key\n * @param {*} val\n */\n\nfunction react (key, val) {\n  current._data[key] = val\n  defineReactive(current._data, key, val)\n  proxy(current, key)\n  return ob\n}\n\n/**\n * $react\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $react (items) {\n  every(items, function (key, val) {\n    react(key, val)\n  })\n  return ob\n}\n\n/**\n * compute\n *\n * @param {String} key\n * @param {Function|Object} accessor\n *        - Function getter\n *        - Object\n *          - Function [get]  - getter\n *          - Function [set]  - setter\n * @param {Boolean} [cache]  - default is true\n */\n\nfunction compute (key, accessor, cache) {\n  var getter, setter\n  if (isFunc(accessor)) {\n    getter = makeComputed(current, accessor)\n    setter = noop\n  } else {\n    getter = accessor.get\n            ? cache !== false\n              ? makeComputed(current, accessor.get)\n              : accessor.get.bind(this)\n            : noop\n    setter = accessor.set ? accessor.set.bind(this) : noop\n  }\n  defi(current, key, getter, setter)\n}\n\n/**\n * $compute\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $compute (items) {\n  every(items, function (key, val) {\n    compute(key, val)\n  })\n  return ob\n}\n\n/**\n * watch\n *\n * @param {String|Function} exprOrFunc\n * @param {Function} callback\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n */\n\nfunction watch (exprOrFunc, callback, options) {\n  return watche(current, exprOrFunc, callback, options || watch)\n}\n\n/**\n * $watch\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $watch (items) {\n  every(items, function (expr, fnOrOpt) {\n    if (isFunc(fnOrOpt)) {\n      watch(expr, fnOrOpt)\n    } else {\n      watch(expr, fnOrOpt.watcher, fnOrOpt)\n    }\n  })\n  return ob\n}\n\n/**\n * proxy\n *\n * @param {Object} owner\n * @param {String} key\n */\n\nfunction proxy (owner, key) {\n  function getter () {\n    return owner._data[key]\n  }\n  function setter (val) {\n    owner._data[key] = val\n  }\n  defi(owner, key, getter, setter)\n}\n"],"names":["def","obj","key","val","enumerable","defineProperty","defi","getter","setter","isPlainObject","toString","call","OBJECT_STRING","indexOf","arr","i","length","isObject","every","cb","keys","Object","l","each","isFunc","func","noop","Dep","id","uid","subs","amend","setPrototypeOf","arrayMethods","$set","index","this","Number","splice","$remove","item","Observer","value","dep","isArray","observeArray","walk","observe","ob","prototype","hasOwnProperty","__ob__","isExtensible","defineReactive","reactiveGetter","target","depend","childOb","e","reactiveSetter","newVal","notify","desc","getOwnPropertyDescriptor","configurable","get","set","makeGetterFn","body","Function","parse","exp","trim","resetBatcherState","flushBatcherQueue","queue","runBatcherQueue","queueIndex","watcher","run","batch","has","push","waiting","Watcher","owner","callback","options","_watchers","active","dirty","lazy","deps","newDeps","depIds","create","newDepIds","undefined","traverse","watch","expOrFn","parseExpression","instance","makeComputed","evaluate","expr","opt","isOber","reactive","auto","init","_data","config","methods","$carry","data","$react","computed","$compute","watchers","$watch","current","react","carry","method","bind","items","compute","accessor","cache","exprOrFunc","watche","fnOrOpt","proxy","_typeof","Symbol","iterator","constructor","Array","isDebug","process","env","NODE_ENV","warn","console","addSub","sub","removeSub","addDep","update","arrayProto","arrayMutating","original","arguments","args","inserted","result","apply","slice","convert","nextTick","nextTickHandler","copies","callbacks","timerFunc","pending","MutationObserver","counter","observer","textNode","document","createTextNode","inBrowser","window","context","global","setImmediate","setTimeout","ctx","beforeGet","scope","deep","afterGet","tmp","sync","oldValue","teardown"],"mappings":"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"}