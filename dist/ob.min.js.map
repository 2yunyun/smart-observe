{"version":3,"file":"ob.min.js","sources":["../src/utils.js","../src/dep.js","../src/array.js","../src/observe.js","../src/expression.js","../src/batcher.js","../src/watcher.js","../src/ob.js"],"sourcesContent":["/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexport function def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Function} getter\n * @param {Function} setter\n */\n\nexport function defi (obj, key, getter, setter) {\n  Object.defineProperty(obj, key, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: true,\n  })\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport const isArray = Array.isArray\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexport function isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexport function indexOf (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport function isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * every\n *\n * @param {Object} obj\n * @param {Function} cb\n */\n\nexport function every (obj, cb) {\n  var keys = Object.keys(obj)\n  for (var i = 0, l = keys.length; i < l; i++) {\n    cb(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * each\n *\n * @param {Array} arr\n * @param {Function} cb\n */\n\nexport function each (arr, cb) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    cb(arr[i], i)\n  }\n}\n\n/**\n * isFunc\n *\n * @param {*} func\n * @param {Boolean}\n */\n\nexport function isFunc (func) {\n  return typeof func === 'function'\n}\n\n/**\n * noop is function which is nothing to do.\n */\n\nexport function noop () {}\n\n/**\n * isDebug\n */\n\nexport const isDebug =\n  typeof process !== 'undefined' &&\n  process.env.NODE_ENV !== 'production'\n\n/**\n * warn\n */\n\nexport const warn =\n  isDebug &&\n  console && isFunc(console.warn)\n  ? console.warn\n  : noop\n","import { each } from './utils'\n\nlet uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nexport default function Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  var subs = this.subs\n  each(subs, function (sub) {\n    sub.update()\n  })\n}\n","import {\n  def,\n  each,\n  indexOf,\n} from './utils'\n\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Intercept mutating methods and emit events\n */\n\neach([\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n], function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\ndef(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = Number(index) + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\ndef(\n  arrayProto,\n  '$remove',\n  function $remove (item) {\n    /* istanbul ignore if */\n    if (!this.length) return\n    var index = indexOf(this, item)\n    if (index > -1) {\n      return this.splice(index, 1)\n    }\n  }\n)\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment (target, src, keys) {\n  each(keys, function (key) {\n    def(target, key, src[key])\n  })\n}\n\n/**\n * Augment an target Object or Array\n *\n * @param {Object|Array} target\n */\n\nconst augment = '__proto__' in {}\n              ? Object.setPrototypeOf\n              : copyAugment\nexport default function amend (target) {\n  augment(target, arrayMethods, arrayKeys)\n}\n","import Dep from './dep'\nimport amendArray from './array'\nimport {\n  def,\n  defi,\n  every,\n  each,\n  isArray,\n  isPlainObject,\n} from './utils'\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  def(value, '__ob__', this)\n  if (isArray(value)) {\n    amendArray(value)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  every(obj, (key, val) => {\n    this.convert(key, val)\n  })\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  each(items, function (val) {\n    observe(val)\n  })\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n */\n\nexport function observe (value) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    Object.prototype.hasOwnProperty.call(value, '__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value)\n  ) {\n    ob = new Observer(value)\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nexport function defineReactive (obj, key, val) {\n  var dep = new Dep()\n\n  var desc = Object.getOwnPropertyDescriptor(obj, key)\n  if (desc && desc.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = desc && desc.get\n  var setter = desc && desc.set\n\n  var childOb = observe(val)\n\n  function reactiveGetter () {\n    var value = getter ? getter.call(obj) : val\n    if (Dep.target) {\n      dep.depend()\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      if (isArray(value)) {\n        each(value, function (e) {\n          e && e.__ob__ && e.__ob__.dep.depend()\n        })\n      }\n    }\n    return value\n  }\n  function reactiveSetter (newVal) {\n    var value = getter ? getter.call(obj) : val\n    if (newVal === value) {\n      return\n    }\n    if (setter) {\n      setter.call(obj, newVal)\n    } else {\n      val = newVal\n    }\n    childOb = observe(newVal)\n    dep.notify()\n  }\n  defi(obj, key, reactiveGetter, reactiveSetter)\n}\n","import { warn } from './utils'\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn (body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';')\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Parse an expression to getter.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nexport default function parse (exp) {\n  exp = exp.trim()\n  var getter = makeGetterFn('scope.' + exp)\n  return getter\n}\n","var queueIndex\nvar queue = []\nvar has = {}\nvar waiting = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    var watcher = queue[queueIndex]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nconst nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    /* global MutationObserver */\n    var observer = new MutationObserver(nextTickHandler)\n    /* global */\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true,\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    const inBrowser = typeof window !== 'undefined' &&\n      Object.prototype.toString.call(window) !== '[object Object]'\n    const context = inBrowser\n      ? window\n      : typeof global !== 'undefined' ? global : {}\n    timerFunc = context.setImmediate || setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport default function batch (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n","import Dep from './dep'\nimport parseExpression from './expression'\nimport batch from './batcher'\nimport {\n  isArray,\n  isObject,\n  isFunc,\n} from './utils'\n\nlet uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nfunction Watcher (owner, getter, callback, options) {\n  owner._watchers.push(this)\n  this.owner = owner\n  this.getter = getter\n  this.callback = callback\n  this.options = options\n  // uid for batching\n  this.id = ++uid\n  this.active = true\n  // for lazy watchers\n  this.dirty = this.options.lazy\n  this.deps = []\n  this.newDeps = []\n  this.depIds = Object.create(null)\n  this.newDepIds = null\n  this.value = this.options.lazy\n    ? undefined\n    : this.get()\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.owner\n  var value = this.getter.call(scope, scope)\n  if (this.options.deep) {\n    traverse(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDepIds = Object.create(null)\n  this.newDeps.length = 0\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDepIds[id]) {\n    this.newDepIds[id] = true\n    this.newDeps.push(dep)\n    if (!this.depIds[id]) {\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var i = this.deps.length\n  while (i--) {\n    var dep = this.deps[i]\n    if (!this.newDepIds[dep.id]) {\n      dep.removeSub(this)\n    }\n  }\n  this.depIds = this.newDepIds\n  var tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\nWatcher.prototype.update = function () {\n  if (this.options.lazy) {\n    this.dirty = true\n  } else if (this.options.sync) {\n    this.run()\n  } else {\n    batch(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even when\n      // the value is the same, because the value may have mutated;\n      ((isObject(value) || this.options.deep))\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      this.callback.call(this.owner, value, oldValue)\n    }\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length\n  while (i--) {\n    this.deps[i].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    var i = this.deps.length\n    while (i--) {\n      this.deps[i].removeSub(this)\n    }\n    this.active = false\n    this.owner = this.callback = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\n/**\n * Create an watcher instance, returns the new watcher.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nexport function watch (owner, expOrFn, callback, options) {\n  // parse expression for getter\n  var getter = isFunc(expOrFn)\n    ? expOrFn\n    : parseExpression(expOrFn)\n  var instance = new Watcher(owner, getter, callback, options)\n  return instance\n}\n\n/**\n * Make a computed getter, which can collect dependencies.\n *\n * @param {Object} owner\n * @param {Function} getter\n */\n\nexport function makeComputed (owner, getter) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true,\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n","import {\n  observe,\n  defineReactive,\n} from './observe.js'\nimport {\n  watch as watche,\n  makeComputed,\n} from './watcher'\nimport {\n  def,\n  defi,\n  every,\n  noop,\n  isFunc,\n} from './utils'\n\nwindow.ob = ob // Just for developing, remove in production\n\nlet current = null\n\n // {Function} One of carry, react, compute, watch. Default is watch.\nob.default = watch\n\n// {Boolean} Default is true\nreactive.auto = true\n\n// {Boolean} Default is false\nwatch.deep = watch.lazy = watch.sync = false\n\nObject.setPrototypeOf(ob, {\n  reactive,\n  carry, $carry,\n  react, $react,\n  compute, $compute,\n  watch, $watch,\n})\n\n/**\n * ob\n *\n * @param {Object} owner\n * @param {*} [expr]\n * @param {*} [func]\n * @param {*} [opt]\n * @return {Function} ob\n */\n\nexport default function ob (owner, expr, func, opt) {\n  current = owner\n  var isOber = owner.hasOwnProperty('_watchers')\n  if (!isOber) {\n    init(owner)\n    if (reactive.auto) {\n      reactive()\n    }\n  }\n  if (expr) {\n    ob.default(expr, func, opt)\n  }\n  return ob\n}\n\n/**\n * init\n *\n * @param {Object} owner\n * @return {Function} ob\n */\n\nfunction init (owner) {\n  def(owner, '_watchers', [], false)\n  def(owner, '_data', Object.create(null), false)\n  observe(owner._data)\n  return ob\n}\n\n/**\n * reactive\n *\n * @param {Object} config\n * @return {Function} ob\n */\n\nfunction reactive (config) {\n  if (config) {\n    config.methods && $carry(config.methods)\n    config.data && $react(config.data)\n    config.computed && $compute(config.computed)\n    config.watchers && $watch(config.watchers)\n  } else {\n    every(current, function (key, val) {\n      !isFunc(val) && react(key, val)\n    })\n  }\n  return ob\n}\n\n/**\n * carry\n *\n * @param {String} key\n * @param {Function} method\n * @param {Object} [bindTo] ///////////////// ?????????????????\n */\n\nfunction carry (key, method) {\n  current[key] = method.bind(current)\n  return ob\n}\n\n/**\n * $carry\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $carry (items) {\n  every(items, function (key, val) {\n    carry(key, val)\n  })\n  return ob\n}\n\n/**\n * react\n *\n * @param {String} key\n * @param {*} val\n * @param {Object} [options]\n *                 - {Boolean} deep ///////////////// ?????????????????\n */\n\nfunction react (key, val) {\n  current._data[key] = val\n  defineReactive(current._data, key, val)\n  proxy(current, key)\n  return ob\n}\n\n/**\n * $react\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $react (items) {\n  every(items, function (key, val) {\n    react(key, val)\n  })\n  return ob\n}\n\n/**\n * compute\n *\n * @param {String} key\n * @param {Function|Object} accessor\n * @param {Object} [options]\n *                 - {Boolean} cache ///////////////// ?????????????????\n */\n\nfunction compute (key, accessor, options) {\n  var getter, setter\n  if (isFunc(accessor)) {\n    getter = makeComputed(current, accessor)\n    setter = noop\n  } else {\n    getter = accessor.get ? makeComputed(current, accessor.get) : noop\n    setter = accessor.set ? accessor.set.bind(this) : noop\n  }\n  defi(current, key, getter, setter)\n  return ob\n}\n\n/**\n * $compute\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $compute (items) {\n  every(items, function (key, val) {\n    compute(key, val)\n  })\n  return ob\n}\n\n/**\n * watch\n *\n * @param {String|Function} exprOrFunc\n * @param {Function} callback\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n */\n\nfunction watch (exprOrFunc, callback, options) {\n  watche(current, exprOrFunc, callback, options || watch)\n}\n\n/**\n * $watch\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $watch (items) {\n  every(items, function (expr, fnOrOpt) {\n    if (isFunc(fnOrOpt)) {\n      watch(expr, fnOrOpt)\n    } else {\n      watch(expr, fnOrOpt.watcher, fnOrOpt)\n    }\n  })\n  return ob\n}\n\n/**\n * proxy\n *\n * @param {Object} owner\n * @param {String} key\n */\n\nfunction proxy (owner, key) {\n  function getter () {\n    return owner._data[key]\n  }\n  function setter (val) {\n    owner._data[key] = val\n  }\n  defi(owner, key, getter, setter)\n}\n"],"names":["def","obj","key","val","enumerable","defineProperty","defi","getter","setter","isPlainObject","toString","call","OBJECT_STRING","indexOf","arr","i","length","isObject","every","cb","keys","Object","l","each","isFunc","func","noop","Dep","id","uid","subs","copyAugment","target","src","amend","arrayMethods","arrayKeys","Observer","value","dep","this","isArray","observeArray","walk","observe","ob","prototype","hasOwnProperty","__ob__","isExtensible","defineReactive","reactiveGetter","depend","childOb","e","reactiveSetter","newVal","notify","desc","getOwnPropertyDescriptor","configurable","get","set","makeGetterFn","body","Function","parse","exp","trim","resetBatcherState","flushBatcherQueue","queue","runBatcherQueue","queueIndex","watcher","run","batch","has","push","waiting","Watcher","owner","callback","options","_watchers","active","dirty","lazy","deps","newDeps","depIds","create","newDepIds","undefined","traverse","watch","expOrFn","parseExpression","instance","makeComputed","evaluate","expr","opt","isOber","reactive","auto","init","_data","config","methods","$carry","data","$react","computed","$compute","watchers","$watch","current","react","carry","method","bind","items","compute","accessor","exprOrFunc","fnOrOpt","proxy","Array","isDebug","process","env","NODE_ENV","warn","console","addSub","sub","removeSub","$remove","addDep","update","arrayProto","getOwnPropertyNames","original","arguments","args","inserted","result","apply","slice","index","Number","splice","item","augment","setPrototypeOf","convert","nextTick","nextTickHandler","copies","callbacks","timerFunc","pending","MutationObserver","counter","observer","textNode","document","createTextNode","inBrowser","window","context","global","setImmediate","setTimeout","ctx","beforeGet","scope","deep","afterGet","tmp","sync","oldValue","teardown"],"mappings":"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"}