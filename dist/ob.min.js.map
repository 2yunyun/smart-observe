{"version":3,"file":"ob.min.js","sources":["../src/utils.js","../src/dep.js","../src/array.js","../src/observe.js","../src/expression.js","../src/batcher.js","../src/watcher.js","../src/ob.js"],"sourcesContent":["/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexport function def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Function} getter\n * @param {Function} setter\n */\n\nexport function defi (obj, key, getter, setter) {\n  Object.defineProperty(obj, key, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: true,\n  })\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport const isArray = Array.isArray\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nvar OBJECT_STRING = '[object Object]'\nexport function isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexport function indexOf (arr, obj) {\n  var i = arr.length\n  while (i--) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexport function isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * every\n *\n * @param {Object} obj\n * @param {Function} cb\n */\n\nexport function every (obj, cb) {\n  var keys = Object.keys(obj)\n  for (var i = 0, l = keys.length; i < l; i++) {\n    cb(keys[i], obj[keys[i]])\n  }\n}\n\n/**\n * each\n *\n * @param {Array} arr\n * @param {Function} cb\n */\n\nexport function each (arr, cb) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    cb(arr[i], i)\n  }\n}\n\n/**\n * isFunc\n *\n * @param {*} func\n * @param {Boolean}\n */\n\nexport function isFunc (func) {\n  return typeof func === 'function'\n}\n\n/**\n * noop is function which is nothing to do.\n */\n\nexport function noop () {}\n\n/**\n * isDebug\n */\n\nexport const isDebug =\n  typeof process !== 'undefined' &&\n  process.env.NODE_ENV !== 'production'\n\n/**\n * warn\n */\n\nexport const warn =\n  isDebug &&\n  console && isFunc(console.warn)\n  ? console.warn\n  : noop\n","import { each } from './utils'\n\nlet uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nexport default function Dep () {\n  this.id = uid++\n  this.subs = []\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  var subs = this.subs\n  each(subs, function (sub) {\n    sub.update()\n  })\n}\n","import {\n  def,\n  each,\n  indexOf,\n} from './utils'\n\nconst arrayProto = Array.prototype\nconst arrayMethods = Object.create(arrayProto)\nconst arrayMutating = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\n\n/**\n * Augment an target Array with arrayMethods\n *\n * @param {Array} arr\n */\n\nexport default function amend (arr) {\n  Object.setPrototypeOf(arr, arrayMethods)\n}\n\n/**\n * Intercept mutating methods and emit events\n */\n\neach(arrayMutating, function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\nfunction $set (index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1\n  }\n  return this.splice(index, 1, val)[0]\n}\ndef(arrayProto, '$set', $set)\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\nfunction $remove (item) {\n  /* istanbul ignore if */\n  if (!this.length) return\n  var index = indexOf(this, item)\n  if (index > -1) {\n    return this.splice(index, 1)\n  }\n}\ndef(arrayProto, '$remove', $remove)\n","import Dep from './dep'\nimport amendArray from './array'\nimport {\n  def,\n  defi,\n  every,\n  each,\n  isArray,\n  isPlainObject,\n} from './utils'\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer (value) {\n  this.value = value\n  this.dep = new Dep()\n  def(value, '__ob__', this)\n  if (isArray(value)) {\n    amendArray(value)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  every(obj, (key, val) => {\n    this.convert(key, val)\n  })\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  each(items, function (val) {\n    observe(val)\n  })\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val)\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n */\n\nexport function observe (value) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    Object.prototype.hasOwnProperty.call(value, '__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value)\n  ) {\n    ob = new Observer(value)\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nexport function defineReactive (obj, key, val) {\n  var dep = new Dep()\n\n  var desc = Object.getOwnPropertyDescriptor(obj, key)\n  if (desc && desc.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = desc && desc.get\n  var setter = desc && desc.set\n\n  var childOb = observe(val)\n\n  function reactiveGetter () {\n    var value = getter ? getter.call(obj) : val\n    if (Dep.target) {\n      dep.depend()\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      if (isArray(value)) {\n        each(value, function (e) {\n          e && e.__ob__ && e.__ob__.dep.depend()\n        })\n      }\n    }\n    return value\n  }\n  function reactiveSetter (newVal) {\n    var value = getter ? getter.call(obj) : val\n    if (newVal === value) {\n      return\n    }\n    if (setter) {\n      setter.call(obj, newVal)\n    } else {\n      val = newVal\n    }\n    childOb = observe(newVal)\n    dep.notify()\n  }\n  defi(obj, key, reactiveGetter, reactiveSetter)\n}\n","import { warn } from './utils'\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn (body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';')\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Parse an expression to getter.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nexport default function parse (exp) {\n  exp = exp.trim()\n  var getter = makeGetterFn('scope.' + exp)\n  return getter\n}\n","var queueIndex\nvar queue = []\nvar has = {}\nvar waiting = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    var watcher = queue[queueIndex]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nconst nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    /* global MutationObserver */\n    var observer = new MutationObserver(nextTickHandler)\n    /* global */\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true,\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    const inBrowser = typeof window !== 'undefined' &&\n      Object.prototype.toString.call(window) !== '[object Object]'\n    const context = inBrowser\n      ? window\n      : typeof global !== 'undefined' ? global : {}\n    timerFunc = context.setImmediate || setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport default function batch (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n","import Dep from './dep'\nimport parseExpression from './expression'\nimport batch from './batcher'\nimport {\n  isArray,\n  isObject,\n  isFunc,\n} from './utils'\n\nlet uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nfunction Watcher (owner, getter, callback, options) {\n  owner._watchers.push(this)\n  this.owner = owner\n  this.getter = getter\n  this.callback = callback\n  this.options = options\n  // uid for batching\n  this.id = ++uid\n  this.active = true\n  // for lazy watchers\n  this.dirty = options.lazy\n  this.deps = []\n  this.newDeps = []\n  this.depIds = Object.create(null)\n  this.newDepIds = null\n  this.value = options.lazy\n    ? undefined\n    : this.get()\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet()\n  var scope = this.owner\n  var value = this.getter.call(scope, scope)\n  if (this.options.deep) {\n    traverse(value)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this\n  this.newDepIds = Object.create(null)\n  this.newDeps.length = 0\n}\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id\n  if (!this.newDepIds[id]) {\n    this.newDepIds[id] = true\n    this.newDeps.push(dep)\n    if (!this.depIds[id]) {\n      dep.addSub(this)\n    }\n  }\n}\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null\n  var i = this.deps.length\n  while (i--) {\n    var dep = this.deps[i]\n    if (!this.newDepIds[dep.id]) {\n      dep.removeSub(this)\n    }\n  }\n  this.depIds = this.newDepIds\n  var tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\nWatcher.prototype.update = function () {\n  if (this.options.lazy) {\n    this.dirty = true\n  } else if (this.options.sync) {\n    this.run()\n  } else {\n    batch(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even when\n      // the value is the same, because the value may have mutated;\n      ((isObject(value) || this.options.deep))\n    ) {\n      // set new value\n      var oldValue = this.value\n      this.value = value\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      this.callback.call(this.owner, value, oldValue)\n    }\n  }\n}\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target\n  this.value = this.get()\n  this.dirty = false\n  Dep.target = current\n}\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length\n  while (i--) {\n    this.deps[i].depend()\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    var i = this.deps.length\n    while (i--) {\n      this.deps[i].removeSub(this)\n    }\n    this.active = false\n    this.owner = this.callback = this.value = null\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nfunction traverse (val) {\n  var i, keys\n  if (isArray(val)) {\n    i = val.length\n    while (i--) traverse(val[i])\n  } else if (isObject(val)) {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) traverse(val[keys[i]])\n  }\n}\n\n/**\n * Create an watcher instance, returns the new watcher.\n *\n * @param {Object} owner\n * @param {String|Function} expOrFn\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @constructor\n */\n\nexport function watch (owner, expOrFn, callback, options) {\n  // parse expression for getter\n  var getter = isFunc(expOrFn)\n               ? expOrFn\n               : parseExpression(expOrFn)\n  var instance = new Watcher(owner, getter, callback, options)\n  return instance\n}\n\n/**\n * Make a computed getter, which can collect dependencies.\n *\n * @param {Object} owner\n * @param {Function} getter\n */\n\nexport function makeComputed (owner, getter) {\n  var watcher = new Watcher(owner, getter, null, {\n    lazy: true,\n  })\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n","import {\n  observe,\n  defineReactive,\n} from './observe'\nimport {\n  watch as watche,\n  makeComputed,\n} from './watcher'\nimport {\n  def,\n  defi,\n  every,\n  noop,\n  isFunc,\n} from './utils'\n\nlet current = null\n\n // {Function} One of carry, react, compute, watch. Default is watch.\nob.default = watch\n\n// {Boolean} Default is true\nreactive.auto = true\n\n// {Boolean} Default is false\nwatch.deep = watch.lazy = watch.sync = false\n\nObject.setPrototypeOf(ob, {\n  reactive,\n  carry, $carry,\n  react, $react,\n  compute, $compute,\n  watch, $watch,\n})\n\n/**\n * ob\n *\n * @param {Object} owner\n * @param {*} [expr]\n * @param {*} [func]\n * @param {*} [opt]\n * @return {Function} ob\n */\n\nexport default function ob (owner, expr, func, opt) {\n  current = owner\n  var isOber = owner.hasOwnProperty('_watchers')\n  if (!isOber) {\n    init(owner)\n    if (reactive.auto) {\n      reactive()\n    }\n  }\n  if (expr) {\n    ob.default(expr, func, opt)\n  }\n  return ob\n}\n\n/**\n * init\n *\n * @param {Object} owner\n * @return {Function} ob\n */\n\nfunction init (owner) {\n  def(owner, '_watchers', [], false)\n  def(owner, '_data', Object.create(null), false)\n  observe(owner._data)\n  return ob\n}\n\n/**\n * reactive\n *\n * @param {Object} config\n * @return {Function} ob\n */\n\nfunction reactive (config) {\n  if (config) {\n    config.methods && $carry(config.methods)\n    config.data && $react(config.data)\n    config.computed && $compute(config.computed)\n    config.watchers && $watch(config.watchers)\n  } else {\n    every(current, function (key, val) {\n      !isFunc(val) && react(key, val)\n    })\n  }\n  return ob\n}\n\n/**\n * carry\n *\n * @param {String} key\n * @param {Function} method\n */\n\nfunction carry (key, method) {\n  current[key] = method.bind(current)\n  return ob\n}\n\n/**\n * $carry\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $carry (items) {\n  every(items, function (key, val) {\n    carry(key, val)\n  })\n  return ob\n}\n\n/**\n * react\n *\n * @param {String} key\n * @param {*} val\n */\n\nfunction react (key, val) {\n  current._data[key] = val\n  defineReactive(current._data, key, val)\n  proxy(current, key)\n  return ob\n}\n\n/**\n * $react\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $react (items) {\n  every(items, function (key, val) {\n    react(key, val)\n  })\n  return ob\n}\n\n/**\n * compute\n *\n * @param {String} key\n * @param {Function|Object} accessor\n *        - Function getter\n *        - Object\n *          - Function [get]  - getter\n *          - Function [set]  - setter\n * @param {Boolean} [cache]  - default is true\n */\n\nfunction compute (key, accessor, cache) {\n  var getter, setter\n  if (isFunc(accessor)) {\n    getter = makeComputed(current, accessor)\n    setter = noop\n  } else {\n    getter = accessor.get\n            ? cache !== false\n              ? makeComputed(current, accessor.get)\n              : accessor.get.bind(this)\n            : noop\n    setter = accessor.set ? accessor.set.bind(this) : noop\n  }\n  defi(current, key, getter, setter)\n}\n\n/**\n * $compute\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $compute (items) {\n  every(items, function (key, val) {\n    compute(key, val)\n  })\n  return ob\n}\n\n/**\n * watch\n *\n * @param {String|Function} exprOrFunc\n * @param {Function} callback\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n */\n\nfunction watch (exprOrFunc, callback, options) {\n  return watche(current, exprOrFunc, callback, options || watch)\n}\n\n/**\n * $watch\n *\n * @param {Object} items\n * @return {Function} ob\n */\n\nfunction $watch (items) {\n  every(items, function (expr, fnOrOpt) {\n    if (isFunc(fnOrOpt)) {\n      watch(expr, fnOrOpt)\n    } else {\n      watch(expr, fnOrOpt.watcher, fnOrOpt)\n    }\n  })\n  return ob\n}\n\n/**\n * proxy\n *\n * @param {Object} owner\n * @param {String} key\n */\n\nfunction proxy (owner, key) {\n  function getter () {\n    return owner._data[key]\n  }\n  function setter (val) {\n    owner._data[key] = val\n  }\n  defi(owner, key, getter, setter)\n}\n"],"names":["def","obj","key","val","enumerable","defineProperty","defi","getter","setter","isPlainObject","toString","call","OBJECT_STRING","indexOf","arr","i","length","isObject","every","cb","keys","Object","l","each","isFunc","func","noop","Dep","id","uid","subs","amend","setPrototypeOf","arrayMethods","$set","index","this","Number","splice","$remove","item","Observer","value","dep","isArray","observeArray","walk","observe","ob","prototype","hasOwnProperty","__ob__","isExtensible","defineReactive","reactiveGetter","target","depend","childOb","e","reactiveSetter","newVal","notify","desc","getOwnPropertyDescriptor","configurable","get","set","makeGetterFn","body","Function","parse","exp","trim","resetBatcherState","flushBatcherQueue","queue","runBatcherQueue","queueIndex","watcher","run","batch","has","push","waiting","Watcher","owner","callback","options","_watchers","active","dirty","lazy","deps","newDeps","depIds","create","newDepIds","undefined","traverse","watch","expOrFn","parseExpression","instance","makeComputed","evaluate","expr","opt","isOber","reactive","auto","init","_data","config","methods","$carry","data","$react","computed","$compute","watchers","$watch","current","react","carry","method","bind","items","compute","accessor","cache","exprOrFunc","watche","fnOrOpt","proxy","Array","isDebug","process","env","NODE_ENV","warn","console","addSub","sub","removeSub","addDep","update","arrayProto","arrayMutating","original","arguments","args","inserted","result","apply","slice","convert","nextTick","nextTickHandler","copies","callbacks","timerFunc","pending","MutationObserver","counter","observer","textNode","document","createTextNode","inBrowser","window","context","global","setImmediate","setTimeout","ctx","beforeGet","scope","deep","afterGet","tmp","sync","oldValue","teardown"],"mappings":"yBASA,SAAgBA,GAAKC,EAAKC,EAAKC,EAAKC,UAC3BC,eAAeJ,EAAKC,SAClBC,eACOC,YACJ,gBACI,IAalB,QAAgBE,GAAML,EAAKC,EAAKK,EAAQC,UAC/BH,eAAeJ,EAAKC,OACpBK,MACAC,gBACS,cACF,IAuBhB,QAAgBC,GAAeR,SACtBS,GAASC,KAAKV,KAASW,EAWhC,QAAgBC,GAASC,EAAKb,UACxBc,GAAID,EAAIE,OACLD,QACDD,EAAIC,KAAOd,EAAK,MAAOc,SAEtB,GAYT,QAAgBE,GAAUhB,SACT,QAARA,GAA+B,+BAARA,2BAAAA,IAUhC,QAAgBiB,GAAOjB,EAAKkB,OAErB,GADDC,GAAOC,OAAOD,KAAKnB,GACdc,EAAI,EAAGO,EAAIF,EAAKJ,OAAYM,EAAJP,EAAOA,MACnCK,EAAKL,GAAId,EAAImB,EAAKL,KAWzB,QAAgBQ,GAAMT,EAAKK,OACpB,GAAIJ,GAAI,EAAGO,EAAIR,EAAIE,OAAYM,EAAJP,EAAOA,MAClCD,EAAIC,GAAIA,GAWf,QAAgBS,GAAQC,SACC,kBAATA,GAOhB,QAAgBC,MCvHhB,QAAwBC,UACjBC,GAAKC,SACLC,QCWP,QAAwBC,GAAOjB,UACtBkB,eAAelB,EAAKmB,GAgD7B,QAASC,GAAMC,EAAOhC,SAChBgC,IAASC,KAAKpB,cACXA,OAASqB,OAAOF,GAAS,GAEzBC,KAAKE,OAAOH,EAAO,EAAGhC,GAAK,GAUpC,QAASoC,GAASC,MAEXJ,KAAKpB,WACNmB,GAAQtB,EAAQuB,KAAMI,SACtBL,GAAQ,GACHC,KAAKE,OAAOH,EAAO,WCvE9B,QAASM,GAAUC,QACZA,MAAQA,OACRC,IAAM,GAAIhB,KACXe,EAAO,SAAUN,MACjBQ,EAAQF,MACCA,QACNG,aAAaH,SAEbI,KAAKJ,GAmDd,QAAgBK,GAASL,MAClBA,GAA0B,+BAAVA,2BAAAA,QAGjBM,SAEF3B,QAAO4B,UAAUC,eAAevC,KAAK+B,EAAO,WAC5CA,EAAMS,iBAAkBV,KAEnBC,EAAMS,QAEVP,EAAQF,IAAUjC,EAAciC,KACjCrB,OAAO+B,aAAaV,OAEf,GAAID,GAASC,IAEbM,GAWT,QAAgBK,GAAgBpD,EAAKC,EAAKC,WAc/BmD,QACHZ,GAAQnC,EAASA,EAAOI,KAAKV,GAAOE,QACpCwB,GAAI4B,WACFC,SACAC,KACMd,IAAIa,SAEVZ,EAAQF,MACLA,EAAO,SAAUgB,MACfA,EAAEP,QAAUO,EAAEP,OAAOR,IAAIa,YAI7Bd,UAEAiB,GAAgBC,MACnBlB,GAAQnC,EAASA,EAAOI,KAAKV,GAAOE,CACpCyD,KAAWlB,IAGXlC,IACKG,KAAKV,EAAK2D,KAEXA,IAEEb,EAAQa,KACdC,aAvCFlB,GAAM,GAAIhB,GAEVmC,EAAOzC,OAAO0C,yBAAyB9D,EAAKC,OAC5C4D,GAAQA,EAAKE,gBAAiB,MAK9BzD,GAASuD,GAAQA,EAAKG,IACtBzD,EAASsD,GAAQA,EAAKI,IAEtBT,EAAUV,EAAQ5C,KA8BjBF,EAAKC,EAAKoD,EAAgBK,ICzIjC,QAASQ,GAAcC,aAGZ,IAAIC,UAAS,QAAS,UAAYD,EAAO,KAEhD,MAAOV,KAEL,gDAC8BU,IAYpC,QAAwBE,GAAOC,KACvBA,EAAIC,UACNjE,GAAS4D,EAAa,SAAWI,SAC9BhE,GC1BT,QAASkE,kBAGG,EAOZ,QAASC,OACSC,OAUlB,QAASC,GAAiBD,OAGnBE,EAAa,EAAGA,EAAaF,EAAM3D,OAAQ6D,IAAc,IACxDC,GAAUH,EAAME,GAChBjD,EAAKkD,EAAQlD,KACbA,GAAM,OACFmD,OA0EZ,QAAwBC,GAAOF,MACzBlD,GAAKkD,EAAQlD,EACF,OAAXqD,EAAIrD,OACFA,GAAM+C,EAAM3D,SACVkE,KAAKJ,GAENK,OACO,IACDT,KC9Ff,QAASU,GAASC,EAAO9E,EAAQ+E,EAAUC,KACnCC,UAAUN,KAAK9C,WAChBiD,MAAQA,OACR9E,OAASA,OACT+E,SAAWA,OACXC,QAAUA,OAEV3D,KAAOC,QACP4D,QAAS,OAETC,MAAQH,EAAQI,UAChBC,aACAC,gBACAC,OAASzE,OAAO0E,OAAO,WACvBC,UAAY,UACZtD,MAAQ6C,EAAQI,KACjBM,OACA7D,KAAK6B,MAwJX,QAASiC,GAAU/F,MACbY,GAAGK,KACHwB,EAAQzC,SACNA,EAAIa,OACDD,OAAcZ,EAAIY,QACpB,IAAIE,EAASd,SACXkB,OAAOD,KAAKjB,KACfiB,EAAKJ,OACFD,OAAcZ,EAAIiB,EAAKL,KAiBlC,QAAgBoF,GAAOd,EAAOe,EAASd,EAAUC,MAE3ChF,GAASiB,EAAO4E,GACLA,EACAC,EAAgBD,GAC3BE,EAAW,GAAIlB,GAAQC,EAAO9E,EAAQ+E,EAAUC,SAC7Ce,GAUT,QAAgBC,GAAclB,EAAO9E,MAC/BuE,GAAU,GAAIM,GAAQC,EAAO9E,EAAQ,YACjC,UAED,kBACDuE,GAAQY,SACFc,WAEN7E,EAAI4B,UACEC,SAEHsB,EAAQpC,OCzMnB,QAAwBM,GAAIqC,EAAOoB,EAAMhF,EAAMiF,MACnCrB,KACNsB,GAAStB,EAAMnC,eAAe,mBAC7ByD,OACEtB,GACDuB,EAASC,WAIXJ,gBACSA,EAAMhF,EAAMiF,GAElB1D,EAUT,QAAS8D,GAAMzB,YACTA,EAAO,gBAAiB,KACxBA,EAAO,QAAShE,OAAO0E,OAAO,OAAO,KACjCV,EAAM0B,OACP/D,EAUT,QAAS4D,GAAUI,SACbA,MACKC,SAAWC,EAAOF,EAAOC,WACzBE,MAAQC,EAAOJ,EAAOG,QACtBE,UAAYC,EAASN,EAAOK,YAC5BE,UAAYC,EAAOR,EAAOO,aAE3BE,GAAS,SAAUvH,EAAKC,IAC3BqB,EAAOrB,IAAQuH,EAAMxH,EAAKC,KAGxB6C,EAUT,QAAS2E,GAAOzH,EAAK0H,aACX1H,GAAO0H,EAAOC,KAAKJ,IACpBzE,EAUT,QAASkE,GAAQY,YACTA,EAAO,SAAU5H,EAAKC,KACpBD,EAAKC,KAEN6C,EAUT,QAAS0E,GAAOxH,EAAKC,aACX4G,MAAM7G,GAAOC,IACNsH,GAAQV,MAAO7G,EAAKC,KAC7BsH,GAASvH,GACR8C,EAUT,QAASoE,GAAQU,YACTA,EAAO,SAAU5H,EAAKC,KACpBD,EAAKC,KAEN6C,EAeT,QAAS+E,GAAS7H,EAAK8H,EAAUC,MAC3B1H,GAAQC,CACRgB,GAAOwG,MACAzB,EAAakB,GAASO,KACtBtG,MAEAsG,EAAS/D,IACRgE,KAAU,EACR1B,EAAakB,GAASO,EAAS/D,KAC/B+D,EAAS/D,IAAI4D,KAAKzF,MACpBV,IACDsG,EAAS9D,IAAM8D,EAAS9D,IAAI2D,KAAKzF,MAAQV,KAE/C+F,GAASvH,EAAKK,EAAQC,GAU7B,QAAS8G,GAAUQ,YACXA,EAAO,SAAU5H,EAAKC,KAClBD,EAAKC,KAER6C,EAcT,QAASmD,GAAO+B,EAAY5C,EAAUC,SAC7B4C,GAAOV,GAASS,EAAY5C,EAAUC,GAAWY,GAU1D,QAASqB,GAAQM,YACTA,EAAO,SAAUrB,EAAM2B,GACvB5G,EAAO4G,KACH3B,EAAM2B,KAEN3B,EAAM2B,EAAQtD,QAASsD,KAG1BpF,EAUT,QAASqF,GAAOhD,EAAOnF,WACZK,WACA8E,GAAM0B,MAAM7G,WAEZM,GAAQL,KACT4G,MAAM7G,GAAOC,IAEhBkF,EAAOnF,EAAKK,EAAQC,2MPnM3B,IAAaoC,GAAU0F,MAAM1F,QAUzBlC,EAAWW,OAAO4B,UAAUvC,SAC5BE,EAAgB,kBAkFP2H,EACQ,mBAAZC,UACkB,eAAzBA,QAAQC,IAAIC,SAMDC,EACXJ,GACAK,SAAWpH,EAAOoH,QAAQD,MACxBC,QAAQD,KACRjH,EClJAG,EAAM,CAiBVF,GAAI4B,OAAS,KAQb5B,EAAIsB,UAAU4F,OAAS,SAAUC,QAC1BhH,KAAKoD,KAAK4D,IASjBnH,EAAIsB,UAAU8F,UAAY,SAAUD,QAC7BhH,KAAKS,QAAQuG,IAOpBnH,EAAIsB,UAAUO,OAAS,aACjBD,OAAOyF,OAAO5G,OAOpBT,EAAIsB,UAAUY,OAAS,cACjB/B,GAAOM,KAAKN,OACXA,EAAM,SAAUgH,KACfG,WClDR,IAAMC,GAAaZ,MAAMrF,UACnBhB,EAAeZ,OAAO0E,OAAOmD,GAC7BC,GACJ,OACA,MACA,QACA,UACA,SACA,OACA,UAiBF5H,GAAK4H,EAAe,SAAUvB,MAExBwB,GAAWF,EAAWtB,KACtB3F,EAAc2F,EAAQ,kBAGpB7G,GAAIsI,UAAUrI,OACdsI,EAAO,GAAIhB,OAAMvH,GACdA,OACAA,GAAKsI,UAAUtI,MAIlBwI,GAFAC,EAASJ,EAASK,MAAMrH,KAAMkH,GAC9BtG,EAAKZ,KAAKe,cAENyE,OACD,SACQ0B,YAER,YACQA,YAER,WACQA,EAAKI,MAAM,SAGtBH,IAAUvG,EAAGH,aAAa0G,KAE3B5G,IAAIkB,SACA2F,MAmBXxJ,EAAIkJ,EAAY,OAAQhH,GAgBxBlC,EAAIkJ,EAAY,UAAW3G,GCtD3BE,EAASQ,UAAUH,KAAO,SAAU7C,gBAC5BA,EAAK,SAACC,EAAKC,KACVwJ,QAAQzJ,EAAKC,MAUtBsC,EAASQ,UAAUJ,aAAe,SAAUiF,KACrCA,EAAO,SAAU3H,KACZA,MAYZsC,EAASQ,UAAU0G,QAAU,SAAUzJ,EAAKC,KAC3BiC,KAAKM,MAAOxC,EAAKC,GEpElC,IAAI0E,GACAF,KACAM,KACAE,GAAU,EAgDRyE,EAAY,mBAIPC,QACG,KACNC,GAASC,EAAUL,MAAM,YAExB,GAAI3I,GAAI,EAAGA,EAAI+I,EAAO9I,OAAQD,MAC1BA,QANPiJ,GAFAD,KACAE,GAAU,KAYkB,mBAArBC,kBAAkC,IACvCC,GAAU,EAEVC,EAAW,GAAIF,kBAAiBL,GAEhCQ,EAAWC,SAASC,eAAeJ,KAC9BpH,QAAQsH,kBACA,MAEL,cACCF,EAAU,GAAK,IACjBhD,KAAOgD,OAEb,IAICK,GAA8B,mBAAXC,SACoB,oBAA3CpJ,OAAO4B,UAAUvC,SAASC,KAAK8J,QAC3BC,EAAUF,EACZC,OACkB,mBAAXE,QAAyBA,YACxBD,EAAQE,cAAgBC,iBAE/B,UAAU1J,EAAI2J,MACfrJ,GAAOqJ,EACP,aAAiBnK,KAAKmK,IACtB3J,IACM+D,KAAKzD,GACXwI,OACM,IACAJ,EAAiB,QCvF3BhI,GAAM,CAwCVuD,GAAQnC,UAAUgB,IAAM,gBACjB8G,eACDC,GAAQ5I,KAAKiD,MACb3C,EAAQN,KAAK7B,OAAOI,KAAKqK,EAAOA,SAChC5I,MAAKmD,QAAQ0F,QACNvI,QAENwI,WACExI,GAOT0C,EAAQnC,UAAU8H,UAAY,aACxBxH,OAASnB,UACR4D,UAAY3E,OAAO0E,OAAO,WAC1BF,QAAQ7E,OAAS,GASxBoE,EAAQnC,UAAU+F,OAAS,SAAUrG,MAC/Bf,GAAKe,EAAIf,EACRQ,MAAK4D,UAAUpE,UACboE,UAAUpE,IAAM,OAChBiE,QAAQX,KAAKvC,GACbP,KAAK0D,OAAOlE,MACXiH,OAAOzG,QASjBgD,EAAQnC,UAAUiI,SAAW,aACvB3H,OAAS,YACTxC,GAAIqB,KAAKwD,KAAK5E,OACXD,KAAK,IACN4B,GAAMP,KAAKwD,KAAK7E,EACfqB,MAAK4D,UAAUrD,EAAIf,OAClBmH,UAAU3G,WAGb0D,OAAS1D,KAAK4D,aACfmF,GAAM/I,KAAKwD,UACVA,KAAOxD,KAAKyD,aACZA,QAAUsF,GAQjB/F,EAAQnC,UAAUgG,OAAS,WACrB7G,KAAKmD,QAAQI,UACVD,OAAQ,EACJtD,KAAKmD,QAAQ6F,UACjBrG,QAEC3C,OASVgD,EAAQnC,UAAU8B,IAAM,cAClB3C,KAAKqD,OAAQ,IACX/C,GAAQN,KAAK6B,SAEfvB,IAAUN,KAAKM,SAGJA,IAAUN,KAAKmD,QAAQ0F,KAClC,IAEII,GAAWjJ,KAAKM,WACfA,MAAQA,OAIR4C,SAAS3E,KAAKyB,KAAKiD,MAAO3C,EAAO2I,MAU5CjG,EAAQnC,UAAUuD,SAAW,cAGvBiB,GAAU9F,EAAI4B,YACbb,MAAQN,KAAK6B,WACbyB,OAAQ,IACTnC,OAASkE,GAOfrC,EAAQnC,UAAUO,OAAS,kBACrBzC,GAAIqB,KAAKwD,KAAK5E,OACXD,UACA6E,KAAK7E,GAAGyC,UAQjB4B,EAAQnC,UAAUqI,SAAW,cACvBlJ,KAAKqD,OAAQ,QACX1E,GAAIqB,KAAKwD,KAAK5E,OACXD,UACA6E,KAAK7E,GAAGgI,UAAU3G,WAEpBqD,QAAS,OACTJ,MAAQjD,KAAKkD,SAAWlD,KAAKM,MAAQ,MCtK9C,IAAI+E,IAAU,QAGdzE,EAAAA,WAAamD,EAGbS,EAASC,MAAO,EAGhBV,EAAM8E,KAAO9E,EAAMR,KAAOQ,EAAMiF,MAAO,EAEvC/J,OAAOW,eAAegB,sBAEbkE,iBACAE,mBACEE,mBACFE"}