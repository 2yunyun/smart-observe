{"version":3,"sources":["../src/batcher.js"],"names":[],"mappings":";;;;;QA+GgB,W,GAAA,W;AA/GhB,IAAI,UAAJ;AACA,IAAI,QAAQ,EAAZ;AACA,IAAI,MAAM,EAAV;AACA,IAAI,UAAU,KAAd;;;;;;AAMA,SAAS,iBAAT,GAA8B;AAC5B,UAAQ,EAAR;AACA,QAAM,EAAN;AACA,YAAU,KAAV;AACD;;;;;;AAMD,SAAS,iBAAT,GAA8B;AAC5B,kBAAgB,KAAhB;AACA;AACD;;;;;;;;AAQD,SAAS,eAAT,CAA0B,KAA1B,EAAiC;;;AAG/B,OAAK,aAAa,CAAlB,EAAqB,aAAa,MAAM,MAAxC,EAAgD,YAAhD,EAA8D;AAC5D,QAAI,UAAU,MAAM,UAAN,CAAd;AACA,QAAI,KAAK,QAAQ,EAAjB;AACA,QAAI,EAAJ,IAAU,IAAV;AACA,YAAQ,GAAR;AACD;AACF;;;;;;;;;;;;AAYD,IAAM,WAAY,YAAY;AAC5B,MAAI,YAAY,EAAhB;AACA,MAAI,UAAU,KAAd;AACA,MAAI,SAAJ;AACA,WAAS,eAAT,GAA4B;AAC1B,cAAU,KAAV;AACA,QAAI,SAAS,UAAU,KAAV,CAAgB,CAAhB,CAAb;AACA,gBAAY,EAAZ;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC,aAAO,CAAP;AACD;AACF;;;AAGD,MAAI,OAAO,gBAAP,KAA4B,WAAhC,EAA6C;AAC3C,QAAI,UAAU,CAAd;;AAEA,QAAI,WAAW,IAAI,gBAAJ,CAAqB,eAArB,CAAf;;AAEA,QAAI,WAAW,SAAS,cAAT,CAAwB,OAAxB,CAAf;AACA,aAAS,OAAT,CAAiB,QAAjB,EAA2B;AACzB,qBAAe;AADU,KAA3B;AAGA,gBAAY,qBAAY;AACtB,gBAAU,CAAC,UAAU,CAAX,IAAgB,CAA1B;AACA,eAAS,IAAT,GAAgB,OAAhB;AACD,KAHD;AAID,GAbD,MAaO;;;;AAIL,QAAM,YAAY,OAAO,MAAP,KAAkB,WAAlB,IAChB,OAAO,SAAP,CAAiB,QAAjB,CAA0B,IAA1B,CAA+B,MAA/B,MAA2C,iBAD7C;AAEA,QAAM,UAAU,YACZ,MADY,GAEZ,OAAO,MAAP,KAAkB,WAAlB,GAAgC,MAAhC,GAAyC,EAF7C;AAGA,gBAAY,QAAQ,YAAR,IAAwB,UAApC;AACD;AACD,SAAO,UAAU,EAAV,EAAc,GAAd,EAAmB;AACxB,QAAI,OAAO,MACP,YAAY;AAAE,SAAG,IAAH,CAAQ,GAAR;AAAc,KADrB,GAEP,EAFJ;AAGA,cAAU,IAAV,CAAe,IAAf;AACA,QAAI,OAAJ,EAAa;AACb,cAAU,IAAV;AACA,cAAU,eAAV,EAA2B,CAA3B;AACD,GARD;AASD,CA/CgB,EAAjB;;;;;;;;;;;;;AA4DO,SAAS,WAAT,CAAsB,OAAtB,EAA+B;AACpC,MAAI,KAAK,QAAQ,EAAjB;AACA,MAAI,IAAI,EAAJ,KAAW,IAAf,EAAqB;AACnB,QAAI,EAAJ,IAAU,MAAM,MAAhB;AACA,UAAM,IAAN,CAAW,OAAX;;AAEA,QAAI,CAAC,OAAL,EAAc;AACZ,gBAAU,IAAV;AACA,eAAS,iBAAT;AACD;AACF;AACF","file":"batcher.js","sourcesContent":["var queueIndex\nvar queue = []\nvar has = {}\nvar waiting = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    var watcher = queue[queueIndex]\n    var id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nconst nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function nextTickHandler () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    /* global MutationObserver */\n    var observer = new MutationObserver(nextTickHandler)\n    /* global */\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true,\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    const inBrowser = typeof window !== 'undefined' &&\n      Object.prototype.toString.call(window) !== '[object Object]'\n    const context = inBrowser\n      ? window\n      : typeof global !== 'undefined' ? global : {}\n    timerFunc = context.setImmediate || setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(nextTickHandler, 0)\n  }\n})()\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport function pushWatcher (watcher) {\n  var id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n"]}